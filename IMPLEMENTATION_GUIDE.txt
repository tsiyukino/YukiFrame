IMPLEMENTATION GUIDE FOR STUB FILES
====================================

This guide helps you implement the stub files in src/core/

OPTION 1: Copy from Original Source (Recommended)
--------------------------------------------------

If you have access to the original Yuki-Frame source:

1. Copy these files directly:
   - src/core/logger.c
   - src/core/event.c
   - src/core/tool.c
   - src/core/config.c
   - src/core/platform_linux.c
   - src/core/platform_windows.c

2. Update any references to control module (it's now integrated)

3. Build and test

OPTION 2: Implement from Scratch
---------------------------------

Use the header files as your contract:

### logger.c

Implement these functions from include/logger.h:
- logger_init()
- logger_shutdown()
- logger_log()
- logger_log_tool()
- logger_set_level()
- logger_rotate()

Key requirements:
- Thread-safe logging
- File output with rotation
- Log level filtering
- Timestamp formatting

### event.c

Implement these functions from include/event.h:
- event_bus_init()
- event_bus_shutdown()
- event_publish()
- event_parse()
- event_format()
- event_process_queue()

Key requirements:
- Circular queue for events
- Event parsing (TYPE|sender|data)
- Event routing to subscribers

### tool.c

Implement these functions from include/tool.h:
- tool_registry_init()
- tool_register()
- tool_start()
- tool_stop()
- tool_restart()
- tool_subscribe()
- tool_send_event()
- tool_check_health()

Key requirements:
- Tool registry (hash table or array)
- Process spawning
- I/O pipe management
- Health monitoring

### config.c

Implement these functions from include/config.h:
- config_load()
- config_reload()
- config_get()
- config_get_int()
- config_get_bool()
- config_get_tools()

Key requirements:
- INI file parsing
- Section/key/value extraction
- Type conversion
- Tool configuration loading

### platform_linux.c / platform_windows.c

Implement these functions from include/platform.h:
- platform_init()
- platform_spawn_process()
- platform_kill_process()
- platform_is_process_running()
- platform_wait_process()
- platform_read_nonblocking()
- platform_write_nonblocking()

Key requirements:
- Process spawning (fork/exec or CreateProcess)
- Pipe creation and I/O
- Non-blocking operations
- Signal/event handling

TESTING STRATEGY
----------------

1. Implement logger.c first
   - Test: Create log file, write messages, check output
   
2. Implement config.c next
   - Test: Load yuki-frame.conf.example, verify parsing

3. Implement platform_*.c
   - Test: Spawn a simple process, check it runs

4. Implement tool.c
   - Test: Register and start tools/echo.py

5. Implement event.c
   - Test: Publish events, verify routing

6. Integration test
   - Test: Run full framework with example tools

MINIMAL WORKING IMPLEMENTATION
-------------------------------

If you want to get something working quickly:

1. logger.c - Simple file logging (no rotation)
2. config.c - Basic INI parsing (no validation)
3. platform_*.c - Fork/exec (Linux) or CreateProcess (Windows)
4. tool.c - Array-based registry, basic start/stop
5. event.c - Simple queue, basic routing

This gets you a working framework. Add features later!

CODE STRUCTURE EXAMPLE
-----------------------

logger.c structure:
```c
#include "logger.h"
#include <stdio.h>
#include <time.h>

static FILE* log_file = NULL;
static LogLevel current_level = LOG_INFO;

int logger_init(const char* filename, LogLevel level) {
    log_file = fopen(filename, "a");
    if (!log_file) return FW_ERROR_IO;
    current_level = level;
    return FW_OK;
}

void logger_log(LogLevel level, const char* component, 
                const char* format, ...) {
    if (level < current_level) return;
    
    // Get timestamp
    char timestamp[32];
    time_t now = time(NULL);
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S",
             localtime(&now));
    
    // Print to file
    fprintf(log_file, "%s [%s] [%s] ", 
            timestamp, level_str(level), component);
    
    va_list args;
    va_start(args, format);
    vfprintf(log_file, format, args);
    va_end(args);
    
    fprintf(log_file, "\n");
    fflush(log_file);
}

// ... rest of implementation
```

Follow similar pattern for other files!

REFERENCE IMPLEMENTATIONS
-------------------------

Check these files for examples:

- main.c - Shows how to initialize everything
- control.c - Shows how to interact with tools
- debug.c - Shows how to log debug events

Use these as templates for your implementations!

GETTING HELP
------------

1. Read the header files - they document what each function should do
2. Look at main.c, control.c, debug.c for examples
3. Check original MODULE_DEVELOPMENT.md for tool interfaces
4. Review ARCHITECTURE.md for system design

You can do this! The hard part (architecture redesign) is done.
You just need to implement the functions! ðŸ’ª
